[{"title":"【覆盖搜索】牛耕法覆盖搜索","url":"/2026/01/27/牛耕法覆盖搜索/","content":"\n> 做项目的时候用到了牛耕法做覆盖搜索，这里简单学习一下\n\n# 问题背景\n\n## 任务\n我们需要探讨的是这样一个问题背景：\n1. 首先我们具有一个待搜索的目标区域，这个区域通常是多变形的，可凸可凹；\n2. 区域内有一些多变形的障碍物，同样可凸可凹；\n3. 搜索区域的智能体（无人机、智能车、扫地机器人之类的）的搜索范围远小于区域面积；\n4. 搜索起点位于待搜索区域的边界上，或可通过一定的规划算法使智能体到达区域边上。\n\n我们的任务是：生成一系列的路径，使得智能体可以完成对于待搜索区的覆盖搜索。\n\n## 难点\n避开区域中的多变形障碍物，实现区域的全覆盖搜索\n\n## 常用算法\n常用以下几种算法进行覆盖搜索：\n1. 牛耕法\n2. 生成树覆盖算法\n3. 深度优先搜索/广度优先搜索\n4. 磨盘法\n\n# 牛耕法介绍\n\nBoustrophedon 意思是牛耕地的方式，是利用平行线覆盖区域。 该模式如下图所示(图源：[知乎](https://zhuanlan.zhihu.com/p/430612058))。\n\n![图片](https://pic4.zhimg.com/v2-3e966112ce6bfbc301cf15e434be0fcd_1440w.jpg)\n\n而对于复杂多多变形而言，需要首先划分搜索区域，然后对每一个区域采用上面的方法进行覆盖搜索。也就是说，整个算法分为大致两个过程：分解和搜索。\n\n## 分解\n牛耕法的分解核心逻辑是吧一个复杂的包含障碍物的多变形区域分解为若干个**互不重叠的**、**单联通的**单元，在每个单元内，智能体可以进行**无障碍**的长距离直线扫描。\n\n![图片](/img/decomposition_result.png \"111\")\n\n\n我们把分解可以分为下面四个步骤\n\n### 识别临界点\n算法使用一条虚拟的扫描线（通常我们用垂直线）从左向右移动，当扫描线扫过地图时，它会不断与多边形边界相交喵。我们需要寻找的是临界点，即这个扫描线与边界交集的地方。我们把临界点分成以下四种：\n1. IN：切入点，扫面线开始碰到一个新的空腔（如障碍物的最左端）\n2. OUT：切出点，扫面线离开一个空腔（如障碍物最右端）\n3. SPLIT：分裂点，到描线有一个连通段\n4. MERGE：合并点，两条扫描线合为一条\n\n### 区域切分\n每当扫描线遇到一个SPLIT或MERGE时，算法就会在这些点画出垂直线，将当前的自由空间切段。在障碍物左侧时，空间分裂成上下两个分支；在障碍物右侧时，上下两个分支重新合并，这些切线将整个地图划分为若干个梯形或单连通多变形。\n\n### 构建邻接图\n切分玩了以后我们需要知道这些区域是咋连接的，所以需要这一步。\n\n在这一步中，我们首先将每个子区域看作一个节点，如果两个子区域在屋里上相邻，就在它们之间连一条边。这样子我们就可以得到很多封闭的区域了喵，这些区域我们可以叫做cell喵（喵喵喵我是可爱的小猫）。通过这些区域，我们可以利用深度优先搜索或者广度优先搜索来规划机器人便利这些区域的先后顺序。\n\n然后通过这一步理论上就可以将任务区域划分到几个Cell。\n\n![image](/img/cells.png)\n\n## 单元路径填充与连接\n在每个Cell内部，由于没有障碍物，直接填充我们在第一节提到的那种平行线覆盖就好啦，当一个Cell扫描完了以后呢，我们就可以根据上一步生成的顺序来搜索下一个Cell了喵！效果是下面这样的（主包加了一点平滑）：\n\n![imges](/img/coverage_result.png)\n\n现在这个算法还有点小问题，主要是搜索顺序上的，我后面修复一下。\n\n# To Be Written\n后面还会补充一下写代码时候遇到的坑，以及讨论一下牛耕法是如何实现相邻区域连续扫描的喵。\n\n","tags":["覆盖","搜索","规划"],"categories":["科研"]},{"title":"RoboMaster配置CAN-FD","url":"/2026/01/26/RoboMaster配置CAN-FD/","content":"\n一个简单的前端实现，用于计算CAN/FDCAN参数: [CANAN/FDCAN 智能参数计算器](https://star-plucking.github.io/canCalculator/)\n\n# can \n对于不兼容fdcan的单片机\n\n需要配置的主要有这几个参数：\n\n## Bit Timings Parameter \n\n### 参数列表\n- Prescaler\n- Time Quanta in Bit Segment 1 （单位time，复数times）\n- Time Quanta in Bit Segment 2 （单位time，复数times）\n- ReSynchronization Jump Width（ 单位time，复数times）\n\n计算得到的一共有如下几个参数：\n\n- Time Quantum （ns）\n- Time for one Bit （nas）\n- Baud Rate （bps）（主要关注）\n\n### 参数计算方法\n\n波特率计算公式：\n\n$$BaudRate = \\frac{CANFrequency \\div Prescaler}{1 + TimeSeg1+TimeSeg2} $$\n\nCANFrequency（FDCAN频率）：CAN时钟频率，查找芯片手册，一般挂载在APB1总线上\n\nPrescaler（预分频器）：CAN频率还需要除预分频系数得到一个更小的频率 方便我们后续计算。假设TimeSeg1和TimeSeg2的值范围在1-32和1-16 如果CAN频率过大算出来可能达不到我们想要的波特率。\n\n### 关于采样点\n\n采样点是在一个 bit 时间里，控制器“读总线电平”的时刻百分比。也就是：这一位走到多少 % 的时候，CAN 才判断 0 / 1。\n\n一个 CAN bit 由这些段组成（单位都是 tq）：\n\n```\n| SyncSeg |   TimeSeg1   | TimeSeg2 |\n|   1     |   Seg1       |  Seg2    |\n```\n\n- SyncSeg：固定 1 tq\n- Seg1：可配置\n- Seg2：可配置\n\n其中采样点在Seq1和Seq2的交界处，即采样点位于\\[SyncSeg+Seg1\\] 之后。所以采样点计算的标准公式为：\n\n$$ SamplePoint = \\frac{1+Seg1}{1+Seg1+Seg2} \\times 100 \\% $$\n\n一般经典CAN常用采样点位87.5%，FDCAN数据段采样点可用75%。这是因为数据段一般速率高，边沿快，一般会高一点。\n\n所以我们选择参数的要求是 采样率（SMP）为75%左右的同时 BRP（Prescaler（预分频器））的值尽量要小，且Sync Jump Width和TimeSeg2两个参数尽量保证一致且较大。\n\nSync Jump Width ≠ 采样点，SJW 是 允许采样点“前后挪动”的最大量，一般有SJW ≤ Seg2。Sync Jump Width和TimeSeg2两个参数尽量保证一致且较大。\n\n## 其他配置（Basic Parameters&Advanced Parameters）\n\n| 分类 | 参数名                               | 中文含义          | 推荐配置                      | 备注 / 原因    |\n| -- | --------------------------------- | ------------- | ------------------------- | ---------- |\n| 基础 | Time Triggered Communication Mode | 时间触发通信        | **Disable**               | RM 不用时间表通信 |\n| 基础 | Automatic Bus-Off Management      | 自动 Bus-Off 恢复 | Disable（老手）<br>Enable（新手） | 抓错误用的     |\n| 基础 | Automatic Wake-Up Mode            | 自动唤醒          | **Disable**               | 不用 Sleep   |\n| 基础 | Automatic Retransmission          | 自动重发          | **Enable**              | CAN 稳定性核心  |\n| 基础 | Receive FIFO Locked Mode          | 接收 FIFO 锁定    | **Disable**               | 保留最新数据     |\n| 基础 | Transmit FIFO Priority            | 发送 FIFO 优先级   | **Enable**              | 控制帧优先      |\n| 高级 | Operating Mode                    | 工作模式          | **Normal**                | 喵帕斯      |\n\n> 是的就是这么简单\n\n# FDCAN （非H7）\n\n> 这一部分针对的是兼容FDCAN的非H7的单片机的配置，主要是H7那个配置有点烦人。喵了个咪的。\n\n## For classic can\n\n### Basic Parameters\n| 参数名                     | 值                      | 含义                | 备注 / 建议          |\n| ----------------------- | ------------------------ | ----------------- | ---------------- |\n| Clock Divider           | Divide kernel clock by 1 | CAN 外设时钟分频        | 1 = 不分频          |\n| Frame Format            | Classic mode             | CAN 帧格式           | 经典 CAN（非 CAN FD） |\n| Mode                    | Normal mode              | 工作模式              | 正常通信             |\n| Auto Retransmission     | Disable                  | 发送失败是否自动重发        | **建议 Enable**    |\n| Transmit Pause          | Disable                  | 连续发送是否插入空闲        | 一般保持 Disable     |\n| Protocol Exception      | Disable                  | CAN FD 协议异常处理     | Classic CAN 必须关  |\n| Nominal Sync Jump Width | 1                        | 同步跳转宽度（SJW）       | 常用 1~4           |\n| Data Prescaler          | 1                        | 数据段分频             | Classic CAN 可忽略  |\n| Data Sync Jump Width    | 1                        | 数据段 SJW           | Classic CAN 可忽略  |\n| Data Time Seg1          | 1                        | 数据段时间段 1          | Classic CAN 可忽略  |\n| Data Time Seg2          | 1                        | 数据段时间段 2          | Classic CAN 可忽略  |\n| Std Filters Nbr         | 0                        | 标准帧滤波器数量（11 位 ID） | **0 = 收不到标准帧**   |\n| Ext Filters Nbr         | 0                        | 扩展帧滤波器数量（29 位 ID） | **0 = 收不到扩展帧**   |\n| Tx FIFO Queue Mode      | FIFO mode                | 发送缓冲方式            | FIFO = 先进先出      |\n\n说明：Frame模式一共有三种工作模式：\n\n- Classic Mode：经典can\n- FD mode without BitRate Switching  无比特率切换模式，整个canfd帧使用同样的比特率\n- FD mode with BitRate Switching  有比特率切换，可以让数据域以更高的比特率传输，提高传输速率，但是要注意can芯片兼容性\n\n关于Filter，我们参照草凡佬的这段话：\n> Std Filters Nbr （标准ID过滤数量） ：这个参数的配置非常容易踩坑，它的参数作用是规定你需要过滤掉标准CANID的数量，通常我们我们不需要过滤任何ID，但这里绝对不能设置为0，如果设置为0则进入不了CAN的中断，必须设置为1即以上，设置为1也不代表我们需要在代码初始化过滤器时过滤掉一个ID，可将一个参数设置为0x00000000，即可不过滤掉任何ID。\n\n所以std设置为1就可以了，ext视情况需要配。\n\n### Bit Timings Parameters\n\n计算方式与一半CAN完全一致，此处略过了喵\n\n要注意的是计算完了以后把上边对于点Data xxxx的数据改成和下面仲裁段配置的一致即可。\n\n需要注意的是此时FDCAN的时钟频率需要在时钟书的“FDCAN Clock Mux”中反复确认喵\n\n## For CAN-FD\n\n### Basic Parameters\n\n> 如果不起用BRS（BitRate Switch）的话，配置方法基本同Classic CAN一致。\n\n如果使用BRS的话，配置方法如下：\n\n首先需要明确的是，在“Basic Parameters”栏目下，Data xxxx相关配置参数之作用于数据段。计算公式为：\n\n$$Bitrate = \\frac{FDCAN_{frq}}{Prescaler \\times (1+Seg1+Seg2)}$$\n\n一定不要忘了采样点的计算喵！\n\n### Bit Timings Parameters\n\n这部分的参数只作用于仲裁段喵！配置方式和经典CAN的一样喵！\n\n\n# FDCAN （H7）\n\n> H7xx，或者说比较新的芯片的配置页面，会多一些参数，所以这里分开说\n\n主要内容其实和其他FDCAN的配置差不多，多了一下几个Basic Parameter的配置参数：\n\n| 参数                     | 是什么            |  推荐值         | 说明                  |\n| ---------------------- | -------------- | ----------- | ------------------- |\n| **Rx Fifo0 Elmts Nbr** | FIFO0 接收消息个数   |  **8（或 ≥1）** | 0 = FIFO0 不存在       |\n| Rx Fifo0 Elmt Size     | FIFO0 单条数据长度   |  **8 / 64**  | Classic 用 8，FD 用 64 |\n| **Rx Fifo1 Elmts Nbr** | FIFO1 接收消息个数   | 0 或 8       | 不用 FIFO1 可设 0       |\n| Rx Fifo1 Elmt Size     | FIFO1 单条数据长度   |  同 FIFO0     |                     |\n| Rx Buffers Nbr         | Rx Buffer 数量   |  0           | 一般不用                |\n| Rx Buffer Size         | Rx Buffer 数据长度 |  默认          |                     |\n\n| 参数                          | 是什么             |  推荐值         | 说明       |\n| --------------------------- | --------------- | ----------- | -------- |\n| Tx Buffers Nbr              | 独立 Tx Buffer 数量 | 0           | 一般不用     |\n| **Tx Fifo Queue Elmts Nbr** | 发送 FIFO 队列深度    |  **8（或 ≥1）** | 0 = 发不出去 |\n| Tx Fifo Queue Mode          | FIFO / Queue    |  FIFO        | FIFO 最常用 |\n| Tx Elmt Size                | 单条发送数据长度        |  8 / 64      | 同 Rx     |\n| Tx Events Nbr | 发送事件记录数量 | 0 或 8 | 不看发送历史可设 0 |\n\n\n这里面的配置看上面的表格基本就可以看懂了喵\n\n然后就是关于这个，一路CAN中  在不加延时的情况下，一次最多能发送或接收的最大帧数据包的数量。草凡佬把它叫做CAN收发最大带宽数。\n\nClock Calibration（时钟校准），Clock Calibration 是给 CAN FD 的“数据段高速通信”用的，主要在 BRS 打开、速率很高（≥2 Mbps）时才有意义。这个后面再加。用了外部晶振基本不用管。\n\n","tags":["RoboMaster","电控","单片机","机器人"],"categories":["RM"]},{"title":"我是废物","url":"/2026/01/25/我是废物/","content":"\n是的我是个废物。\n\n所以你看见这篇文章就知道我是个废物了。\n\n很抱歉你看见了我的博客，你现在快点退出去吧，以免伤了你的大脑。\n\n这么低质量的东西，没必要你在这里浪费时间的。\n\n对不起是我多虑了因为没人会读到这里的。\n\n或者说从一开始这就是错误的。\n\n从一开始我就是废物的，但是作为一个合格的废物，我是不会去努力让自己提高的。\n\n如说是那样的话活了这么多年我早就不是废物了是吧。\n\n或者说，我这几年也是白活了。\n\n反正也不剩多少了。\n\n从很早很早开始我就意识到了我是个废物，一个不知努力为何物的废物。\n\n是啊，世界上哪里还存在干啥啥都不行的人呢？\n\n学习，一点不会的；\n\n科研，一窍不通的；\n\n游戏，现在还没玩懂一个游戏，还没有通关一个有意义的游戏；\n\n娱乐，呵，有什么娱乐项目，刷视频算是娱乐吗；\n\n爱好，我没有什么爱好。\n\n环顾我的周围，我什么都是没有的，什么都是空的。学习我是没有学习的动力。科研，我是不会的，因为一开始就没有去了解科研的动力，这个东西于我而言是陌生的，我无法静下心来真的看一篇论文————即使看了，也是大概率看不懂的。哦，要说我又什么科研方向的话，我也不知道了，我也不知道要去研究什么，要去看什么，要去了解什么。将来，我要做点什么呢，不知道啊。有没有将来啊，我不知道，我并非很确定能不能活到那个时候。我要去干什么呢，我该去干什么呢，我是要干什么呢。我已经不知道了。\n\n所以什么是游戏和娱乐？为什么要去游戏啊？你有那个时间吗？你该做的事情都做完了吗？万一你玩了一半有人叫你该怎么办？所以游戏是很悲催的，因为这个东西想搞好，很难，非常难。我一向是觉得，能完好游戏的人，尤其是那些在游戏中取得一定的成就，或者对游戏有一定独到见解的，以及玩完一款游戏能够给出发自内心评价的，已经绝非等闲之辈了。当然这样的人去做别的也都会做的不错的，热情是最大的杀手锏。那么多人嘴上说说自己不想科研也好学习也好，他们都是可以很认真的处理好的，或者说对他们来说，这就是常规的状态呢，因为只要投入进去，当然是能把事情做的有模有样的，因为从玩游戏的态度就可以看出来对于事情的专注力他们是不缺少的。这很好。\n\n娱乐上也是这样的道理吧，我一向觉得游戏是一门艺术，不管是做游戏还是玩游戏，这些行为和踢球、绘画、弹琴、雕塑是没有任何区别的，其他的各种行为也是没什么区别。都是类似的。都是和之前的分析是类似的。将身心全部投入一件事情中去，是一件非常浪漫，非常高尚的事情，是一切事情的顶点，是至高无上的。\n\n可悲的是，我～似乎～无法做到任何一件事情。这就是我可悲的一生。因为想做的事情太多了，所以什么都做不了，于是就是这样了。我得到了什么吗？什么也没有；我失去了什么吗？什么也没有。或者就是这样了。连去探索一点新事物的热情，都见不到了，因为新事物一定是做不到了，因为你不知道自己的探索是否有效，路径是否正确，是否浪费时间，是否能够达成一定的成果，这些既然都不是确定的，为什么要去做呢？为什么呢？没必要，既然看见了，那就只是看见了呗，你还真的想去参与进去吗？你不害臊吗你做不到的啊，因为这个过程太难了啊，是吧！！！！\n\n我已经不想对这种废物说什么了，祝这种废物早日去世，这种人简直是在浪费资源。\n\n真是可悲的人生。\n\n","tags":["科研太累了"],"categories":["烂文"]},{"title":"苦水","url":"/2026/01/21/苦水/","content":"\n我累了，被傻逼横向这么了这几天，我累了。  \n绝非人类啊，ai写的代码用不了，一开始又💩又长的代码。\n我不想看了，能不能赶紧去死。\n\n# 问题的根源\n\n从根源上讲，横向这个东西就很神奇。为什么这么说呢。首先我们看为什么要做横向，不为别的，经费嘛，做科研需要很多经费，买卡也要，买电脑也好，买无人机也好，还有差旅之类的，总之就是很费钱。正常这些钱怎么给呢，差旅理论上要找学校报销的吧，还有神秘的180元差补；仪器设备呢，其实理论上要从基金里面找的，但是基金呢，他是有限的，像是我这条贱狗的导师累死累活申请出来一个某自然也就30多万的经费，我说实话完全不够花，这么多学生，这么多试验设备，钱花的流水一样，而且基金是长年的啊，所以平坦到没人每年这钱可就更少了。这很坏，即使算上大导师的百万经费，我说实话肯定还是不够花的，因为项目越大就是越烧钱，这是很显然的一个道理。\n\n\n# 项目的本质与超级甲方\n所以我们就需要项目。项目这个东西，很神秘，有七八万的小项目，有千万级的大项目。而在这一系列的项目中，又数横向项目最折磨人。为什么这么说呢，横向这玩意儿，首先，他与你的研究课题是弱相关的，甚至很多时候是不相关的，只是你的专业能力是允许你去做的而已，所以从过程上讲你是不会从这个过程中学习到任何能力，如果有，大概是抗压的能力。因为项目里面有个东西，他叫甲方，一个很不得了的东西。通常，这是一个企业，当然这个企业一定是与你的导师有着千丝万缕的联系了，某工肯定偏向于有点gf背景的了，然后呢，这个企业会提出一些看似很容易达成的目标。然后你就上钩了，你就哇哇哇的过去咬掉了这口。当然其实大部分时候并不是你咬下去的，导师会先把你挂上去的，你也没法挣脱，比较，你要毕业的。接下来就是无尽的折磨了，因为甲方会一个东西，他叫“提出新的要求”。诶这个就很有意思了，因为往往招标的时候给你定下的目标也不高，概念也很笼统———那么细节呢？你猜细节呢？诶嘿，当然是慢慢的给出来了！没过一个时间节点，甲方给你抛出一点，然后，你就要美美的重构你的代码。于是你就陷入了这个endless repeat，新要求，重构。最后，你会得到一坨面目全非的代码，复杂且低效，甚至，充满了面向结果的变成方法.\n\n# 该破防了\n然后，你就炸缸了。在项目验收的前夜，你看见自己的项目文档没有写完，这不可怕；你看见你似乎并没有百分之百cover甲方的需求，这也不可怕；最最最可怕的是，你发现，你写了很久的代码，当然我承认有很大的一部分是vibe coding，在这个项目验收的前夜，他炸了，彻彻底底的炸了，炸的面目全非，炸的完完全全。\n\n然后你就累了，彻彻底底的累了。我是不知道这是不是人类了。或许从一开始就没人人类，从一开始我就不应该去做横向——这是我不想吗——应该更加深层次的说，或许，在某理工读研就是一个很傻逼的事情。或者说，我是说有没有一种可能，我是来科研的？\n\n\n我已经不明白了。\n\n![图片](/img/ZY.png \"ZY\")\n\n","tags":["科研太累了"]},{"title":"Hello World","url":"/2026/01/06/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]